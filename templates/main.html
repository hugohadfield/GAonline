<!DOCTYPE html>
<html>

 <head>
    <meta charset=utf-8>
    <title>GA online</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <style>
            body { margin: 500; margin-right: 100; overflow: hidden}
            canvas { width: 100%; height: 100%; overflow: hidden}
    </style>
</head>


<body>

<div id="scene3d"></div>
<div style="position: fixed; bottom: 0; left: 0; border: 0;">
<textarea id="myTextarea" rows="30" cols="50" style="resize: none;" >
DrawSphere(-(3.0^e1234) - (2.0^e1235) + (2.0^e1245) - (1.0^e1345) + (1.0^e2345));
DrawPlane((0.57735^e1234) + (0.57735^e1235) - (0.57735^e1245) + (0.57735^e1345) - (0.57735^e2345));
DrawLine(-(0.70711^e124) - (0.70711^e125) - (0.70711^e145) - (0.70711^e245));
</textarea>
<button onclick="ParseUserScript()">Execute script</button>
</div>


    <script src="static/three.js"></script>
    <script src="static/OrbitControls.js"></script>

    <script>
        
/* 
This section of the code deals with parseing text input from the user
*/

// All 4,1 canonical blade strings
var blades = {"e1":1,"e2":2,"e3":3,"e4":4,"e5":5,
"e12":6,"e13":7,"e14":8,"e15":9,"e23":10,"e24":11,"e25":12,"e34":13,"e35":14,"e45":15,
"e123":16,"e124":17,"e125":18,"e134":19,"e135":20,"e145":21,"e234":22,"e235":23,"e245":24,"e345":25,
"e1234":26,"e1235":27,"e1245":28,"e1345":29,"e2345":30,"e12345":31};

// Regex that extract the blades from the input string
var bladeRegex = /((^|\s)-?\s?\d+(\.\d+)?)\s|(-\s?\d+(\.\d+)?\^e\d+(\s|$))|((^|\+)\s?\d+(\.\d+)?\^e\d+(\s|$))/g;

function parseMultivector(str){

    // Split the string
    str = str.replace(/[()]/g, "");
    var myStringArray = str.match(bladeRegex);

    // Now iterate over the array and extract the information
    var present_blades = {}
    for (var i = 0; i < myStringArray.length; i++) {
        // Trim the whitespace
        thisString = myStringArray[i].trim();
        // Split on the ^ symbol
        var stuff = thisString.split("^");
        //
        if (stuff.length === 2){
            // Extract the value of the blade and the index of the blade
            var blade_val = parseFloat(stuff[0].replace(/ /g,''));
            blade_index = blades[stuff[1].replace(/ /g,'')]
            present_blades[blade_index] = blade_val;
        }
        else{
            if(stuff.length === 1){
                // Extract the value of the scalar
                var blade_val = parseFloat(stuff[0].replace(/ /g,''));
                var blade_index = 0;
                present_blades[blade_index] = blade_val;
            }
        }
    }
    return present_blades
}

function callFunction(funcName,mvArg,scene){
    present_blades = parseMultivector(mvArg);
    window[funcName](present_blades,scene);
}


// Regex tha extracts the functions with their arguments
var functionRegex = /\w+\(.+\)/g;

function parseScriptToFunctions(str,scene){
    var myStringArray = str.match(functionRegex);
    for (var i = 0; i < myStringArray.length; i++) {
        var thisFunctionString = myStringArray[i];
        var funcName = thisFunctionString.split(/\(/,1)[0];
        console.log(funcName);
        var mvArg = thisFunctionString.slice(funcName.length+1,-1);
        console.log(mvArg);
        callFunction(funcName,mvArg,scene);
    }
}

function get_sphere(present_blades){
    return $.ajax({
                url : "to_sphere/",
                type : "POST",
                data : { 'present_blades' : JSON.stringify(present_blades) } ,
            });
}

function get_plane(present_blades){
    return $.ajax({
                url : "to_plane/",
                type : "POST",
                data : { 'present_blades' : JSON.stringify(present_blades) } ,
            });
}

function get_line(present_blades){
    return $.ajax({
                url : "to_line/",
                type : "POST",
                data : { 'present_blades' : JSON.stringify(present_blades) } ,
            });
}

/*
This section creates the scene and axes
*/

function buildAxis( src, dst, colorHex, dashed ) {
    var geom = new THREE.Geometry(),
        mat;
    if(dashed) {
            mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
    } else {
            mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex, transparent: true, opacity:0.2  });
    }
    geom.vertices.push( src.clone() );
    geom.vertices.push( dst.clone() );
    geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines
    var axis = new THREE.Line( geom, mat, THREE.LinePieces );
    return axis;
}

function buildAxes( length ) {
    var axes = new THREE.Object3D();
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, false) ); // -X
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, false ) ); // -Y
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, false ) ); // -Z
    return axes;
}

function MapToAxisSystem(vectorin){
    return [vectorin[0],vectorin[1],vectorin[2]];
}



function DrawSphere(present_blades,scene){
    // Get the sphere parameters and draw it on return
    get_sphere(present_blades).success(function (returned_data) {
        console.log(returned_data);
        var centre = MapToAxisSystem(returned_data.centre);
        var radius = returned_data.radius;
        var geometry = new THREE.SphereGeometry( radius, 32, 32 );
        var material = new THREE.MeshBasicMaterial( {color: 0xff0000, wireframe: true} );
        var sphere = new THREE.Mesh( geometry, material );
        sphere.position.set(centre[0],centre[1],centre[2])
        scene.add(sphere);
    });
}

function DrawPlane(present_blades,scene){
    // Get the sphere parameters and draw it on return
    get_plane(present_blades).success(function (returned_data) {
        console.log(returned_data);
        var distance = returned_data.distance;
        var normal = MapToAxisSystem(returned_data.normal);
        var position = [normal[0]*distance,normal[1]*distance,normal[2]*distance];
        
        // Add a floor
        var geometry = new THREE.PlaneGeometry( 100, 100, 100, 100 );
        var material = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true} );
        var plane = new THREE.Mesh( geometry, material );
        plane.material.side = THREE.DoubleSide;
        plane.lookAt(normal[0],normal[1],normal[2]);
        plane.position.set(position[0],position[1],position[2]);
        scene.add( plane );
    });
}


function DrawLine(present_blades,scene){
    // Get the sphere parameters and draw it on return
    get_line(present_blades).success(function (returned_data) {
        console.log(returned_data);
        var direction = MapToAxisSystem(returned_data.direction);
        var point = MapToAxisSystem(returned_data.point);
        
        var material = new THREE.LineBasicMaterial({
            color: 0x000000
        });
        var geometry = new THREE.Geometry();
        geometry.vertices.push(
            new THREE.Vector3( point[0]+500*direction[0], point[1]+500*direction[1], point[2]+500*direction[2] ),
            new THREE.Vector3( point[0]-500*direction[0], point[1]-500*direction[1], point[2]-500*direction[2] )
        );
        var line = new THREE.Line( geometry, material );
        scene.add( line );
    });
}


// Set up the scene and window size
var scene = new THREE.Scene();
var canvas_width = window.innerWidth;
var canvas_height = window.innerHeight;

// Create a camera object
var camera = new THREE.PerspectiveCamera( 75, canvas_width/canvas_height, 0.1, 1000 );

// Set up orbit controls
container = document.getElementById( 'scene3d' );
camera.position.set( 5, 0, 5 );
camera.up.set( 0, 0, 1 );
var controls = new THREE.OrbitControls( camera, container );
controls.update();

// Create a renderer and add it to the DOM
var renderer = new THREE.WebGLRenderer({ alpha: true });
renderer.setSize( canvas_width, canvas_height);
container.appendChild( renderer.domElement );

// Do the things
function ParseUserScript(){
    // Get the input string
    var input_str = document.getElementById("myTextarea").value;
    // Clear the scene
    resetScene(scene);
    // Add the new stuff
    parseScriptToFunctions(input_str,scene);
}

ParseUserScript()


function resetScene(scene){
    // Remove everything from the scene first
    for (let i = scene.children.length - 1; i >= 0; i--) {
        if(scene.children[i].type === "Mesh"){
            scene.remove(scene.children[i]);
        }
    }
    // Build coordinate axes
    axes = buildAxes( 1000 );
    scene.add(axes);
    // Add a floor
    var geometry = new THREE.PlaneGeometry( 100, 100, 100, 100 );
    var material = new THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe: true, transparent: true, opacity: 0.2} );
    var plane = new THREE.Mesh( geometry, material );
    scene.add(plane);
}

// Animate the scene
var animate = function () {
    requestAnimationFrame( animate );
    // required if controls.enableDamping or controls.autoRotate are set to true
    controls.update();
    renderer.render(scene, camera);
};
animate();


    </script>

</body>
</html>
